#!/bin/bash
# inject-knowledge.sh — SubagentStart hook
# Injects context from SQLite knowledge store into agent spawn.
# Replaces generate_context_brief() from taskplex.sh.
#
# Input: JSON on stdin with agent_id, agent_type
# Output: JSON on stdout with hookSpecificOutput.additionalContext
# Exit 0 always (never blocks agent creation)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source "$SCRIPT_DIR/scripts/knowledge-db.sh" 2>/dev/null || true

# Read hook input from stdin
HOOK_INPUT=$(cat)

# Extract fields
AGENT_TYPE=$(echo "$HOOK_INPUT" | jq -r '.agent_type // ""' 2>/dev/null)
AGENT_ID=$(echo "$HOOK_INPUT" | jq -r '.agent_id // ""' 2>/dev/null)

# Find project root (look for prd.json)
PROJECT_DIR="$(pwd)"
PRD_FILE="$PROJECT_DIR/prd.json"
CONFIG_FILE="$PROJECT_DIR/.claude/taskplex.config.json"

# Determine knowledge DB path
KNOWLEDGE_DB="$PROJECT_DIR/knowledge.db"
if [ -f "$CONFIG_FILE" ]; then
  CONFIGURED_DB=$(jq -r '.knowledge_db // ""' "$CONFIG_FILE" 2>/dev/null)
  if [ -n "$CONFIGURED_DB" ]; then
    KNOWLEDGE_DB="$PROJECT_DIR/$CONFIGURED_DB"
  fi
fi

# If no DB exists, try migration from knowledge.md then bail
if [ ! -f "$KNOWLEDGE_DB" ]; then
  if [ -f "$PROJECT_DIR/knowledge.md" ]; then
    init_knowledge_db "$KNOWLEDGE_DB" 2>/dev/null || true
    migrate_knowledge_md "$KNOWLEDGE_DB" "$PROJECT_DIR/knowledge.md" 2>/dev/null || true
  else
    # No knowledge store at all — exit cleanly with no context
    echo '{}'
    exit 0
  fi
fi

# If no PRD, nothing to inject
if [ ! -f "$PRD_FILE" ]; then
  echo '{}'
  exit 0
fi

# Find the in_progress story
STORY_ID=$(jq -r '.userStories[] | select(.status == "in_progress") | .id' "$PRD_FILE" 2>/dev/null | head -1)

if [ -z "$STORY_ID" ]; then
  echo '{}'
  exit 0
fi

# Build context brief
CONTEXT=""

# 1. Story details
STORY_JSON=$(jq --arg id "$STORY_ID" '.userStories[] | select(.id == $id)' "$PRD_FILE" 2>/dev/null)
CONTEXT="${CONTEXT}# Context Brief for ${STORY_ID}
Generated by TaskPlex knowledge injection hook

## Story Details
\`\`\`json
${STORY_JSON}
\`\`\`

"

# 2. Run check_before_implementing commands
CHECK_CMDS=$(jq -r --arg id "$STORY_ID" \
  '.userStories[] | select(.id == $id) | .check_before_implementing // [] | .[]' \
  "$PRD_FILE" 2>/dev/null)

if [ -n "$CHECK_CMDS" ]; then
  CONTEXT="${CONTEXT}## Pre-Implementation Check Results
"
  while IFS= read -r cmd; do
    if [ -n "$cmd" ]; then
      CHECK_OUTPUT=$(eval "$cmd" 2>&1 || echo "(command returned non-zero)")
      CONTEXT="${CONTEXT}### \`${cmd}\`
\`\`\`
${CHECK_OUTPUT}
\`\`\`

"
    fi
  done <<< "$CHECK_CMDS"
fi

# 3. Dependency diffs
DEP_IDS=$(jq -r --arg id "$STORY_ID" \
  '.userStories[] | select(.id == $id) | .depends_on // [] | .[]' \
  "$PRD_FILE" 2>/dev/null)

if [ -n "$DEP_IDS" ]; then
  CONTEXT="${CONTEXT}## Dependency Story Changes
"
  while IFS= read -r dep_id; do
    if [ -n "$dep_id" ]; then
      DEP_COMMIT=$(git log --oneline --grep="feat($dep_id)" -1 --format="%H" 2>/dev/null)
      if [ -n "$DEP_COMMIT" ]; then
        DEP_DIFF=$(git diff "${DEP_COMMIT}^".."${DEP_COMMIT}" --stat 2>/dev/null || echo "(diff not available)")
        CONTEXT="${CONTEXT}### ${dep_id} (commit: ${DEP_COMMIT:0:8})
\`\`\`
${DEP_DIFF}
\`\`\`

"
      fi
    fi
  done <<< "$DEP_IDS"
fi

# 4. Relevant learnings from SQLite (with confidence decay)
RELATED_TO=$(jq -r --arg id "$STORY_ID" \
  '.userStories[] | select(.id == $id) | .related_to // [] | .[]' \
  "$PRD_FILE" 2>/dev/null)
DEPENDS_ON=$(jq -r --arg id "$STORY_ID" \
  '.userStories[] | select(.id == $id) | .depends_on // [] | .[]' \
  "$PRD_FILE" 2>/dev/null)

# Build tags filter from related_to and depends_on
TAGS_JSON="["
FIRST=true
for tag in $RELATED_TO $DEPENDS_ON $STORY_ID; do
  if [ "$FIRST" = true ]; then
    FIRST=false
  else
    TAGS_JSON="${TAGS_JSON},"
  fi
  TAGS_JSON="${TAGS_JSON}\"${tag}\""
done
TAGS_JSON="${TAGS_JSON}]"

LEARNINGS=$(query_learnings "$KNOWLEDGE_DB" 10 "$TAGS_JSON" 2>/dev/null)

if [ -n "$LEARNINGS" ]; then
  CONTEXT="${CONTEXT}## Project Knowledge (from previous stories)
"
  while IFS='|' read -r content story_id confidence; do
    CONTEXT="${CONTEXT}- [${story_id}] (confidence: ${confidence}) ${content}
"
  done <<< "$LEARNINGS"
  CONTEXT="${CONTEXT}
"
fi

# 5. Error history (if retry)
STORY_ATTEMPTS=$(echo "$STORY_JSON" | jq -r '.attempts // 0' 2>/dev/null)
if [ "$STORY_ATTEMPTS" -gt 1 ] 2>/dev/null; then
  ERRORS=$(query_errors "$KNOWLEDGE_DB" "$STORY_ID" 2>/dev/null)
  if [ -n "$ERRORS" ]; then
    CONTEXT="${CONTEXT}## Previous Error History
"
    while IFS='|' read -r category message attempt resolved; do
      # No 'local' here — while-in-pipe runs in subshell in bash 3.2
      status="unresolved"
      [ "$resolved" = "1" ] && status="resolved"
      CONTEXT="${CONTEXT}- Attempt ${attempt}: [${category}] ${message} (${status})
"
    done <<< "$ERRORS"
    CONTEXT="${CONTEXT}
"
  fi

  # Include last_error and retry_hint from PRD
  LAST_ERROR=$(echo "$STORY_JSON" | jq -r '.last_error // empty' 2>/dev/null)
  if [ -n "$LAST_ERROR" ]; then
    CONTEXT="${CONTEXT}## Previous Failure Context
Last error: ${LAST_ERROR}
Please address this issue and try again.

"
  fi
fi

# Escape the context for JSON output
ESCAPED_CONTEXT=$(echo "$CONTEXT" | jq -Rs '.' 2>/dev/null)

# Output hook response
cat <<HOOK_OUTPUT
{
  "hookSpecificOutput": {
    "hookEventName": "SubagentStart",
    "additionalContext": ${ESCAPED_CONTEXT}
  }
}
HOOK_OUTPUT

exit 0
