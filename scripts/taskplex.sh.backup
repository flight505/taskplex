#!/bin/bash
# TaskPlex - Long-running AI agent loop with process management
# Usage: ./taskplex.sh [max_iterations]

set -e

# ============================================================================
# Process Management & Cleanup
# ============================================================================

# Global variable to track current Claude process
CURRENT_CLAUDE_PID=""

# Cleanup function - called on any exit (normal, interrupt, error)
cleanup() {
  local exit_code=$?

  log "CLEANUP" "Cleanup triggered (exit code: $exit_code)"

  # Only clean up OUR child process, not others
  if [ -n "$CURRENT_CLAUDE_PID" ]; then
    log "CLEANUP" "Checking if Claude process $CURRENT_CLAUDE_PID is running..."
    if ps -p "$CURRENT_CLAUDE_PID" > /dev/null 2>&1; then
      log "CLEANUP" "Terminating Claude process $CURRENT_CLAUDE_PID..."
      echo ""
      echo "âš ï¸  Shutting down this TaskPlex instance..."

      # Try graceful termination first
      kill -TERM "$CURRENT_CLAUDE_PID" 2>/dev/null || true
      sleep 2

      # Force kill if still running
      if ps -p "$CURRENT_CLAUDE_PID" > /dev/null 2>&1; then
        log "CLEANUP" "Process still running, force killing..."
        kill -9 "$CURRENT_CLAUDE_PID" 2>/dev/null || true
      else
        log "CLEANUP" "Process terminated gracefully"
      fi
    else
      log "CLEANUP" "Claude process already terminated"
    fi
  else
    log "CLEANUP" "No active Claude process to clean up"
  fi

  # Clean up THIS instance's PID file only (per-branch)
  if [ -f "$PRD_FILE" ]; then
    BRANCH_NAME=$(jq -r '.branchName // "unknown"' "$PRD_FILE" 2>/dev/null || echo "unknown")
    PID_FILE="$PROJECT_DIR/.claude/taskplex-${BRANCH_NAME}.pid"
    log "CLEANUP" "Checking for PID file: $PID_FILE"
    if [ -f "$PID_FILE" ]; then
      log "CLEANUP" "Removing PID file: $PID_FILE"
      rm -f "$PID_FILE"
    fi
  fi

  log "CLEANUP" "Cleanup complete"
  exit $exit_code
}

# Register cleanup on ALL exit scenarios
log "INIT" "Registering signal handlers (EXIT, INT, TERM, HUP)"
trap cleanup EXIT INT TERM HUP

# ============================================================================
# Logging Functions
# ============================================================================

# Structured logging function with timestamp and prefix
log() {
  local prefix="$1"
  local message="$2"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%S)] [$prefix] $message" >&2
}

# Trim progress.txt file if it exceeds size limit
trim_progress() {
  local max_size=512000  # 500KB limit

  if [ ! -f "$PROGRESS_FILE" ]; then
    return 0
  fi

  local current_size=$(wc -c < "$PROGRESS_FILE" 2>/dev/null || echo "0")

  if [ "$current_size" -gt "$max_size" ]; then
    log "INIT" "Progress file exceeds ${max_size} bytes, trimming old entries..."

    # Preserve Codebase Patterns section (first 50 lines) and truncate rest
    local temp_file=$(mktemp)
    head -50 "$PROGRESS_FILE" > "$temp_file" && mv "$temp_file" "$PROGRESS_FILE"

    log "INIT" "Progress file trimmed: $(wc -c < "$PROGRESS_FILE") bytes remaining"
  fi
}

# ============================================================================
# Authentication Check
# ============================================================================

# Check authentication (OAuth preferred, API key as fallback)
if [ -n "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
  # OAuth authentication (primary - Max subscribers)
  unset ANTHROPIC_API_KEY ANTHROPIC_ADMIN_KEY
  echo "âœ“ Using Claude Code OAuth authentication"

elif [ -n "$ANTHROPIC_API_KEY" ]; then
  # API key fallback
  echo "âœ“ Using Anthropic API Key authentication"
  echo "ðŸ’¡ Tip: Max subscribers can use 'claude setup-token' for better rate limits"

else
  # No authentication found
  echo "Error: No authentication configured"
  echo ""
  echo "TaskPlex requires authentication:"
  echo ""
  echo "Recommended: OAuth Token (Claude Max subscribers)"
  echo "  1. Run: claude setup-token"
  echo "  2. export CLAUDE_CODE_OAUTH_TOKEN='your-token'"
  echo ""
  echo "Alternative: API Key"
  echo "  1. Get from: https://console.anthropic.com/settings/keys"
  echo "  2. export ANTHROPIC_API_KEY='your-key'"
  echo ""
  exit 1
fi

# ============================================================================
# Timeout Command Detection
# ============================================================================

# Detect which timeout command is available (GNU coreutils)
# macOS with Homebrew coreutils: gtimeout
# Linux: timeout
if command -v gtimeout &> /dev/null; then
  TIMEOUT_CMD="gtimeout"
elif command -v timeout &> /dev/null; then
  TIMEOUT_CMD="timeout"
else
  echo "Error: timeout command not found (GNU coreutils required)"
  echo ""
  echo "Install coreutils:"
  echo "  macOS: brew install coreutils"
  echo "  Linux: sudo apt-get install coreutils"
  echo ""
  exit 1
fi

# ============================================================================
# Configuration
# ============================================================================

MAX_ITERATIONS=${1:-10}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Plugin root is parent of scripts directory
PLUGIN_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
# Work in the user's project directory (current working directory)
PROJECT_DIR="$(pwd)"
PRD_FILE="$PROJECT_DIR/prd.json"
PROGRESS_FILE="$PROJECT_DIR/progress.txt"
ARCHIVE_DIR="$PROJECT_DIR/archive"
LAST_BRANCH_FILE="$PROJECT_DIR/.last-branch"
CONFIG_FILE="$PROJECT_DIR/.claude/taskplex.config.json"

# Validate PRD file
validate_prd() {
  if [ ! -f "$PRD_FILE" ]; then
    log "ERROR" "prd.json not found at $PRD_FILE"
    echo "" >&2
    echo "TaskPlex requires a valid prd.json file in the project root." >&2
    echo "Run 'claude /prd-generator' to create one." >&2
    echo "" >&2
    exit 1
  fi

  # Validate JSON syntax
  if ! jq empty "$PRD_FILE" 2>/dev/null; then
    log "ERROR" "prd.json is not valid JSON"
    log "ERROR" "File: $PRD_FILE"
    exit 1
  fi

  # Validate required fields
  local user_stories_count=$(jq -r '.userStories | length' "$PRD_FILE" 2>/dev/null || echo "0")
  if [ "$user_stories_count" -eq 0 ]; then
    log "ERROR" "prd.json must contain a userStories array with at least one entry"
    exit 1
  fi

  local branch_name=$(jq -r '.branchName // empty' "$PRD_FILE" 2>/dev/null)
  if [ -z "$branch_name" ]; then
    log "ERROR" "prd.json must contain a branchName field"
    exit 1
  fi

  log "INIT" "PRD validation passed: $user_stories_count stories found"
}

# Load configuration from JSON config file
load_config() {
  # Default values
  ITERATION_TIMEOUT=900
  EXECUTION_MODE="foreground"
  EXECUTION_MODEL="sonnet"
  EFFORT_LEVEL=""
  BRANCH_PREFIX="taskplex"
  MAX_RETRIES_PER_STORY=2
  MERGE_ON_COMPLETE=false
  MAX_TURNS=200
  TEST_COMMAND=""
  BUILD_COMMAND=""
  TYPECHECK_COMMAND=""

  # Load from config file if it exists
  if [ -f "$CONFIG_FILE" ]; then
    log "INIT" "Reading configuration from $CONFIG_FILE"

    ITERATION_TIMEOUT=$(jq -r '.iteration_timeout // 900' "$CONFIG_FILE")
    EXECUTION_MODE=$(jq -r '.execution_mode // "foreground"' "$CONFIG_FILE")
    EXECUTION_MODEL=$(jq -r '.execution_model // "sonnet"' "$CONFIG_FILE")
    EFFORT_LEVEL=$(jq -r '.effort_level // ""' "$CONFIG_FILE")
    BRANCH_PREFIX=$(jq -r '.branch_prefix // "taskplex"' "$CONFIG_FILE")
    MAX_RETRIES_PER_STORY=$(jq -r '.max_retries_per_story // 2' "$CONFIG_FILE")
    MERGE_ON_COMPLETE=$(jq -r '.merge_on_complete // false' "$CONFIG_FILE")
    MAX_TURNS=$(jq -r '.max_turns // 200' "$CONFIG_FILE")
    TEST_COMMAND=$(jq -r '.test_command // ""' "$CONFIG_FILE")
    BUILD_COMMAND=$(jq -r '.build_command // ""' "$CONFIG_FILE")
    TYPECHECK_COMMAND=$(jq -r '.typecheck_command // ""' "$CONFIG_FILE")

    log "INIT" "Configuration loaded from $CONFIG_FILE"
  else
    log "INIT" "No config file found, using defaults"
  fi

  # Log key configuration values
  log "INIT" "Iteration timeout: ${ITERATION_TIMEOUT}s ($(($ITERATION_TIMEOUT / 60)) minutes)"
  log "INIT" "Execution mode: $EXECUTION_MODE"
  log "INIT" "Execution model: $EXECUTION_MODEL"
  [ -n "$EFFORT_LEVEL" ] && log "INIT" "Effort level: $EFFORT_LEVEL"
}

# Update story status in prd.json
update_story_status() {
  local story_id="$1"
  local new_status="$2"
  local error_msg="${3:-}"
  local error_category="${4:-}"

  if [ ! -f "$PRD_FILE" ]; then
    echo "[ERROR] Cannot update story status: prd.json not found" >&2
    return 1
  fi

  TEMP_PRD=$(mktemp)

  if [ "$new_status" = "in_progress" ]; then
    # Set status to in_progress and increment attempts
    jq --arg id "$story_id" --arg status "$new_status" '
      .userStories |= map(
        if .id == $id then
          .status = $status |
          .attempts = (.attempts // 0) + 1
        else . end
      )
    ' "$PRD_FILE" > "$TEMP_PRD" && mv "$TEMP_PRD" "$PRD_FILE"

  elif [ "$new_status" = "completed" ]; then
    # Set status to completed, passes to true, clear errors
    jq --arg id "$story_id" --arg status "$new_status" '
      .userStories |= map(
        if .id == $id then
          .status = $status |
          .passes = true |
          .last_error = null |
          .last_error_category = null
        else . end
      )
    ' "$PRD_FILE" > "$TEMP_PRD" && mv "$TEMP_PRD" "$PRD_FILE"

  elif [ "$new_status" = "skipped" ]; then
    # Set status to skipped, preserve error information
    jq --arg id "$story_id" --arg status "$new_status" \
       --arg error "$error_msg" --arg category "$error_category" '
      .userStories |= map(
        if .id == $id then
          .status = $status |
          .last_error = (if $error != "" then $error else .last_error end) |
          .last_error_category = (if $category != "" then $category else .last_error_category end)
        else . end
      )
    ' "$PRD_FILE" > "$TEMP_PRD" && mv "$TEMP_PRD" "$PRD_FILE"

  else
    echo "[ERROR] Unknown status: $new_status" >&2
    rm -f "$TEMP_PRD"
    return 1
  fi

  echo "[STATUS] Story $story_id set to $new_status" >&2
}

# Get next eligible task (incomplete, dependencies satisfied, not skipped)
get_next_task() {
  if [ ! -f "$PRD_FILE" ]; then
    echo "[ERROR] Cannot get next task: prd.json not found" >&2
    return 1
  fi

  # Use jq to find the first incomplete story with all dependencies satisfied
  # sorted by priority (lowest number = highest priority)
  local next_task
  next_task=$(jq -r '
    # First, get all stories for dependency checking
    .userStories as $all_stories |

    # Filter to incomplete, non-skipped stories
    .userStories[] |
    select(.passes == false and .status != "skipped") |

    # Check if all dependencies are satisfied
    select(
      # No dependencies, or empty array, or all deps have passes=true
      (.depends_on == null) or
      (.depends_on | length == 0) or
      (
        .depends_on | all(. as $dep_id |
          $all_stories | map(select(.id == $dep_id and .passes == true)) | length > 0
        )
      )
    ) |

    # Return ID with priority for sorting
    {id: .id, priority: .priority}
  ' "$PRD_FILE" | jq -s 'sort_by(.priority) | .[0].id // empty' 2>/dev/null)

  if [ -z "$next_task" ]; then
    # Check if there are any incomplete stories at all
    local incomplete_count
    incomplete_count=$(jq '[.userStories[] | select(.passes == false and .status != "skipped")] | length' "$PRD_FILE")

    if [ "$incomplete_count" -eq 0 ]; then
      # All stories complete or skipped
      return 1
    else
      # Stories exist but all are blocked by dependencies
      echo "[ERROR] All remaining stories are blocked by unmet dependencies" >&2
      return 2
    fi
  fi

  echo "$next_task"
  return 0
}

# Setup git branch - create or checkout the branch from prd.json
setup_branch() {
  local branch_name
  branch_name=$(jq -r '.branchName // empty' "$PRD_FILE")

  if [ -z "$branch_name" ]; then
    echo "[ERROR] No branchName found in prd.json" >&2
    return 1
  fi

  # Get current branch
  local current_branch
  current_branch=$(git branch --show-current 2>/dev/null || echo "")

  if [ "$current_branch" = "$branch_name" ]; then
    echo "[INIT] Already on branch: $branch_name" >&2
    return 0
  fi

  # Check if branch exists locally
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    # Branch exists - check it out
    echo "[INIT] Checking out existing branch: $branch_name" >&2
    if git checkout "$branch_name" 2>&1; then
      echo "[INIT] Switched to branch: $branch_name" >&2
      return 0
    else
      echo "[ERROR] Failed to checkout branch: $branch_name" >&2
      return 1
    fi
  else
    # Branch doesn't exist - create it
    echo "[INIT] Creating new branch: $branch_name" >&2
    if git checkout -b "$branch_name" 2>&1; then
      echo "[INIT] Created and switched to branch: $branch_name" >&2
      return 0
    else
      echo "[ERROR] Failed to create branch: $branch_name" >&2
      return 1
    fi
  fi
}

# Commit story changes
commit_story() {
  local story_id="$1"
  local story_title="$2"

  if [ -z "$story_id" ] || [ -z "$story_title" ]; then
    echo "[ERROR] commit_story requires story_id and story_title" >&2
    return 1
  fi

  # Check if there are any changes to commit
  if [ -z "$(git status --porcelain)" ]; then
    echo "[COMMIT] No changes to commit for $story_id" >&2
    return 0
  fi

  # Stage tracked file changes (implementer should have staged, but fallback)
  # Use git add -u (update tracked files) as safety - don't use git add -A which could commit secrets
  if ! git diff --cached --quiet 2>/dev/null; then
    echo "[COMMIT] Files already staged by implementer" >&2
  else
    echo "[COMMIT] Staging tracked file changes (fallback)" >&2
    git add -u
  fi

  # Commit with conventional commit format
  local commit_msg="feat($story_id): $story_title"

  if git commit -m "$commit_msg" 2>&1; then
    echo "[COMMIT] Committed: $commit_msg" >&2
    return 0
  else
    echo "[ERROR] Failed to commit changes for $story_id" >&2
    return 1
  fi
}

# Merge feature branch to main
merge_to_main() {
  local branch_name
  branch_name=$(jq -r '.branchName // empty' "$PRD_FILE")

  local project_name
  project_name=$(jq -r '.project // "TaskPlex"' "$PRD_FILE")

  local description
  description=$(jq -r '.description // ""' "$PRD_FILE")

  if [ -z "$branch_name" ]; then
    echo "[ERROR] No branchName found in prd.json" >&2
    return 1
  fi

  # Check merge_on_complete config
  if [ "$MERGE_ON_COMPLETE" != "true" ]; then
    echo "[MERGE] Merge skipped (merge_on_complete is false in config)" >&2
    echo "[MERGE] Feature branch '$branch_name' is ready for manual merge" >&2
    return 0
  fi

  # Get current branch
  local current_branch
  current_branch=$(git branch --show-current 2>/dev/null || echo "")

  if [ "$current_branch" != "$branch_name" ]; then
    echo "[ERROR] Not on expected branch. Current: $current_branch, Expected: $branch_name" >&2
    return 1
  fi

  # Checkout main branch
  echo "[MERGE] Checking out main branch..." >&2
  if ! git checkout main 2>&1; then
    echo "[ERROR] Failed to checkout main branch" >&2
    echo "[MERGE] Staying on branch: $branch_name" >&2
    git checkout "$branch_name" 2>/dev/null
    return 1
  fi

  # Merge with --no-ff to preserve feature branch history
  local merge_msg="feat: $project_name - $description"
  echo "[MERGE] Merging $branch_name into main with --no-ff..." >&2

  if git merge --no-ff "$branch_name" -m "$merge_msg" 2>&1; then
    echo "[MERGE] âœ“ Successfully merged $branch_name into main" >&2
    return 0
  else
    # Merge conflict
    echo "[ERROR] Merge conflict detected!" >&2
    echo "[MERGE] Branch '$branch_name' has conflicts with main" >&2
    echo "[MERGE] Please resolve conflicts manually:" >&2
    echo "  1. git status (see conflicted files)" >&2
    echo "  2. Edit files to resolve conflicts" >&2
    echo "  3. git add <resolved-files>" >&2
    echo "  4. git commit" >&2
    echo "" >&2
    # Abort merge to leave clean state
    git merge --abort 2>/dev/null
    # Go back to feature branch
    git checkout "$branch_name" 2>/dev/null
    return 1
  fi
}

# Validate PRD before proceeding
validate_prd

# Load configuration
load_config

# Export effort level as env var for Claude CLI (Opus 4.6 adaptive reasoning)
if [ -n "$EFFORT_LEVEL" ] && [ "$EXECUTION_MODEL" = "opus" ]; then
  export CLAUDE_CODE_EFFORT_LEVEL="$EFFORT_LEVEL"
  echo "[INIT] CLAUDE_CODE_EFFORT_LEVEL=$EFFORT_LEVEL (Opus 4.6 adaptive reasoning)" >&2
fi

# Archive previous run if branch changed
if [ -f "$PRD_FILE" ] && [ -f "$LAST_BRANCH_FILE" ]; then
  CURRENT_BRANCH=$(jq -r '.branchName // empty' "$PRD_FILE" 2>/dev/null || echo "")
  LAST_BRANCH=$(cat "$LAST_BRANCH_FILE" 2>/dev/null || echo "")

  if [ -n "$CURRENT_BRANCH" ] && [ -n "$LAST_BRANCH" ] && [ "$CURRENT_BRANCH" != "$LAST_BRANCH" ]; then
    # Archive the previous run
    DATE=$(date +%Y-%m-%d)
    # Strip "taskplex/" prefix from branch name for folder
    FOLDER_NAME=$(echo "$LAST_BRANCH" | sed 's|^taskplex/||')
    ARCHIVE_FOLDER="$ARCHIVE_DIR/$DATE-$FOLDER_NAME"

    echo "Archiving previous run: $LAST_BRANCH"
    mkdir -p "$ARCHIVE_FOLDER"
    [ -f "$PRD_FILE" ] && cp "$PRD_FILE" "$ARCHIVE_FOLDER/"
    [ -f "$PROGRESS_FILE" ] && cp "$PROGRESS_FILE" "$ARCHIVE_FOLDER/"
    echo "   Archived to: $ARCHIVE_FOLDER"

    # Reset progress file for new run
    echo "# TaskPlex Progress Log" > "$PROGRESS_FILE"
    echo "Started: $(date)" >> "$PROGRESS_FILE"
    echo "---" >> "$PROGRESS_FILE"
  fi
fi

# Track current branch
if [ -f "$PRD_FILE" ]; then
  CURRENT_BRANCH=$(jq -r '.branchName // empty' "$PRD_FILE" 2>/dev/null || echo "")
  if [ -n "$CURRENT_BRANCH" ]; then
    echo "$CURRENT_BRANCH" > "$LAST_BRANCH_FILE"
  fi
fi

# Initialize progress file if it doesn't exist
if [ ! -f "$PROGRESS_FILE" ]; then
  echo "# TaskPlex Progress Log" > "$PROGRESS_FILE"
  echo "Started: $(date)" >> "$PROGRESS_FILE"
  echo "---" >> "$PROGRESS_FILE"
fi

# ============================================================================
# Per-Branch Instance Check
# ============================================================================

# Extract branch name from PRD for per-branch PID file
BRANCH_NAME=$(jq -r '.branchName // "unknown"' "$PRD_FILE" 2>/dev/null || echo "unknown")
INSTANCE_PID_FILE="$PROJECT_DIR/.claude/taskplex-${BRANCH_NAME}.pid"

echo "[INIT] Branch: $BRANCH_NAME" >&2
echo "[INIT] Instance PID file: $INSTANCE_PID_FILE" >&2

# Check if TaskPlex is already running on THIS branch
if [ -f "$INSTANCE_PID_FILE" ]; then
  EXISTING_PID=$(cat "$INSTANCE_PID_FILE")
  echo "[INIT] Found existing PID file with PID: $EXISTING_PID" >&2
  if ps -p "$EXISTING_PID" > /dev/null 2>&1; then
    echo "âŒ Error: TaskPlex already running on branch '$BRANCH_NAME' (PID: $EXISTING_PID)"
    echo "This prevents duplicate work on the same feature."
    echo ""
    echo "Options:"
    echo "  - Wait for it to finish"
    echo "  - Stop it: kill $EXISTING_PID"
    echo "  - View logs: tail -f .claude/taskplex.log"
    exit 1
  else
    # Stale PID file, remove it
    echo "[INIT] PID $EXISTING_PID not running, removing stale PID file" >&2
    rm -f "$INSTANCE_PID_FILE"
  fi
fi

# Save our PID for this branch
echo "[INIT] Saving our PID ($$) to $INSTANCE_PID_FILE" >&2
mkdir -p "$(dirname "$INSTANCE_PID_FILE")"
echo $$ > "$INSTANCE_PID_FILE"

# Setup git branch (US-006)
setup_branch || {
  echo "[ERROR] Failed to setup git branch" >&2
  exit 1
}

# ============================================================================
# Main Execution Loop
# ============================================================================

echo "Starting TaskPlex - Max iterations: $MAX_ITERATIONS"
echo "Branch: $BRANCH_NAME"
echo "Model: $EXECUTION_MODEL$([ -n "$EFFORT_LEVEL" ] && echo " (effort: $EFFORT_LEVEL)")"
echo "PID: $$"
echo "Timeout: ${ITERATION_TIMEOUT}s per iteration"

# ============================================================================
# Error Categorization and Retry Logic (US-004)
# ============================================================================

# Define max retries per error category
declare -A CATEGORY_MAX_RETRIES=(
  ["env_missing"]=0
  ["test_failure"]=2
  ["timeout"]=1
  ["code_error"]=2
  ["dependency_missing"]=0
  ["unknown"]=1
)

# Function to categorize errors based on exit code and output
# Returns error category: env_missing, test_failure, timeout, code_error, dependency_missing, unknown
categorize_error() {
  local exit_code=$1
  local output=$2

  # Timeout (exit code 124 from timeout command)
  if [ "$exit_code" -eq 124 ]; then
    echo "timeout"
    return
  fi

  # Environment/credentials missing
  if echo "$output" | grep -iqE 'API key|token|credentials|ECONNREFUSED|environment variable'; then
    echo "env_missing"
    return
  fi

  # Dependency missing (npm, python modules, etc.)
  if echo "$output" | grep -iqE 'npm ERR|ModuleNotFoundError|cannot find module'; then
    echo "dependency_missing"
    return
  fi

  # Test failure
  if echo "$output" | grep -iqE 'FAIL|test.*failed|assertion'; then
    echo "test_failure"
    return
  fi

  # Code error (syntax, type, lint errors)
  if echo "$output" | grep -iqE 'SyntaxError|TypeError|error TS|lint'; then
    echo "code_error"
    return
  fi

  # Unknown category
  echo "unknown"
}

# Function to handle errors with category-specific retry logic
# Args: iteration, story_id, exit_code, output
# Returns: 0=skip, 1=abort, 2=retry
handle_error() {
  local iteration=$1
  local story_id=$2
  local exit_code=$3
  local output=$4

  # Categorize the error
  local category=$(categorize_error "$exit_code" "$output")

  echo "" >&2
  echo "[ERROR] Iteration $iteration failed with category: $category" >&2

  # Get current attempts for this story
  local attempts=$(jq -r --arg id "$story_id" '.userStories[] | select(.id == $id) | .attempts // 0' "$PRD_FILE")

  # Get max retries for this category
  local max_retries=${CATEGORY_MAX_RETRIES[$category]:-1}

  # Log to progress file
  echo "" >> "$PROGRESS_FILE"
  echo "## Iteration $iteration - ERROR ($category)" >> "$PROGRESS_FILE"
  echo "Story: $story_id" >> "$PROGRESS_FILE"
  echo "Attempts: $attempts" >> "$PROGRESS_FILE"
  echo "Max retries for $category: $max_retries" >> "$PROGRESS_FILE"
  echo "---" >> "$PROGRESS_FILE"

  # Update story with error details
  if [ -n "$story_id" ] && [ -f "$PRD_FILE" ]; then
    TEMP_PRD=$(mktemp)
    # Extract first 200 chars of error for last_error field
    local error_excerpt=$(echo "$output" | head -c 200 | tr '\n' ' ')
    jq --arg id "$story_id" \
       --arg category "$category" \
       --arg error "$error_excerpt" '
      .userStories |= map(
        if .id == $id then
          .last_error = $error |
          .last_error_category = $category
        else . end
      )
    ' "$PRD_FILE" > "$TEMP_PRD" && mv "$TEMP_PRD" "$PRD_FILE"
  fi

  # Check if we should retry or skip
  if [ "$attempts" -gt "$max_retries" ]; then
    # Exceeded max retries for this category
    echo "[ERROR] Attempts ($attempts) exceeded max retries ($max_retries) for category $category" >&2
    echo "[ERROR] Marking story $story_id as skipped" >&2

    # Mark as skipped
    update_story_status "$story_id" "skipped"

    if [ "$EXECUTION_MODE" = "foreground" ]; then
      # Show interactive prompt even when skipping
      echo ""
      echo "âš ï¸  Story $story_id failed ($category)"
      echo "Attempts: $attempts, Max retries: $max_retries"
      echo ""
      echo "Options:"
      echo "  1. Skip story and continue (recommended)"
      echo "  2. Retry anyway (override max retries)"
      echo "  3. Abort TaskPlex execution"
      echo ""
      read -p "Choice (1-3): " choice

      case $choice in
        1)
          echo "Skipping story, continuing to next..."
          return 0
          ;;
        2)
          echo "Retrying despite max retries..."
          return 2
          ;;
        3)
          echo "Aborting TaskPlex execution"
          return 1
          ;;
        *)
          echo "Invalid choice, skipping story..."
          return 0
          ;;
      esac
    else
      # Background mode - auto-skip
      return 0
    fi
  fi

  # Retries remaining
  if [ "$EXECUTION_MODE" = "foreground" ]; then
    # Interactive mode - ask user
    local remaining=$((max_retries - attempts + 1))
    echo ""
    echo "âš ï¸  Iteration $iteration failed ($category)"
    echo "Attempts: $attempts, Retries remaining: $remaining"
    echo ""
    echo "Options:"
    echo "  1. Skip story and continue"
    echo "  2. Retry with context from this attempt"
    echo "  3. Abort TaskPlex execution"
    echo ""
    read -p "Choice (1-3): " choice

    case $choice in
      1)
        echo "Skipping story, continuing to next..."
        update_story_status "$story_id" "skipped"
        return 0
        ;;
      2)
        echo "Retrying with error context..."
        return 2
        ;;
      3)
        echo "Aborting TaskPlex execution"
        return 1
        ;;
      *)
        echo "Invalid choice, retrying..."
        return 2
        ;;
    esac
  else
    # Background mode - auto-retry if retries remain
    echo "âš ï¸  Iteration $iteration failed ($category). Retrying ($attempts/$max_retries)..." >&2
    return 2
  fi
}

# Function to run validator agent after story implementation
# Args: story_id
# Returns: 0=validation passed, 1=validation failed
run_validator() {
  local story_id=$1

  echo "[VALIDATE-$story_id] Starting validation..." >&2

  # Get story details from PRD
  local story_json=$(jq --arg id "$story_id" '.userStories[] | select(.id == $id)' "$PRD_FILE")
  local story_title=$(echo "$story_json" | jq -r '.title')
  local acceptance_criteria=$(echo "$story_json" | jq -r '.acceptanceCriteria[]')

  # Build validator prompt
  local validator_prompt="# Validation Task

Story ID: $story_id
Story Title: $story_title

## Acceptance Criteria

$(echo "$story_json" | jq -r '.acceptanceCriteria | to_entries | map("\(.key + 1). \(.value)") | .[]')

## Test Commands

$(if [ -n "$TEST_COMMAND" ]; then echo "Test command: $TEST_COMMAND"; fi)
$(if [ -n "$TYPECHECK_COMMAND" ]; then echo "Typecheck command: $TYPECHECK_COMMAND"; fi)
$(if [ -n "$BUILD_COMMAND" ]; then echo "Build command: $BUILD_COMMAND"; fi)

## Your Task

Verify each acceptance criterion above. For each criterion:
1. Run any verification commands specified in the criterion
2. Check that the expected outcome is met
3. Report pass/fail

Output your result as JSON in this format:
{
  \"story_id\": \"$story_id\",
  \"validation_result\": \"pass\" or \"fail\",
  \"criteria_results\": [
    {\"criterion\": \"...\", \"result\": \"pass\", \"details\": \"...\"}
  ],
  \"test_suite_result\": \"pass\" or \"fail\" or \"not_configured\"
}
"

  # Use shorter timeout for validation (1/3 of iteration timeout)
  local validation_timeout=$((ITERATION_TIMEOUT / 3))

  # Run validator agent
  VALIDATOR_OUTPUT=$($TIMEOUT_CMD $validation_timeout claude -p "$validator_prompt" \
    --output-format json \
    --no-session-persistence \
    --agent validator \
    --agents-dir "$PLUGIN_ROOT/agents" \
    2>&1)

  local validator_exit=$?

  # Check if validator ran successfully
  if [ $validator_exit -ne 0 ]; then
    echo "[VALIDATE-$story_id] Validator failed to run (exit code: $validator_exit)" >&2
    echo "[VALIDATE-$story_id] Output: $VALIDATOR_OUTPUT" >&2
    return 1
  fi

  # Parse validation result
  local validation_result=$(echo "$VALIDATOR_OUTPUT" | jq -r '.result.validation_result // empty' 2>/dev/null)

  # Fallback: check for "pass" or "fail" in output
  if [ -z "$validation_result" ]; then
    if echo "$VALIDATOR_OUTPUT" | grep -iq '"validation_result".*"pass"'; then
      validation_result="pass"
    elif echo "$VALIDATOR_OUTPUT" | grep -iq '"validation_result".*"fail"'; then
      validation_result="fail"
    else
      echo "[VALIDATE-$story_id] Could not parse validation result" >&2
      echo "[VALIDATE-$story_id] Output: $VALIDATOR_OUTPUT" >&2
      return 1
    fi
  fi

  echo "[VALIDATE-$story_id] Validation result: $validation_result" >&2

  # Log validation output
  echo "" >> "$PROGRESS_FILE"
  echo "## Validation - $story_id" >> "$PROGRESS_FILE"
  echo "Result: $validation_result" >> "$PROGRESS_FILE"
  echo "$VALIDATOR_OUTPUT" >> "$PROGRESS_FILE"
  echo "---" >> "$PROGRESS_FILE"

  if [ "$validation_result" = "pass" ]; then
    echo "[VALIDATE-$story_id] Validation passed âœ“" >&2
    return 0
  else
    echo "[VALIDATE-$story_id] Validation failed âœ—" >&2
    return 1
  fi
}

for i in $(seq 1 $MAX_ITERATIONS); do
  echo ""
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "  TaskPlex Iteration $i of $MAX_ITERATIONS"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # Get next eligible story (respects dependencies)
  CURRENT_STORY=$(get_next_task)
  GET_NEXT_EXIT=$?

  if [ $GET_NEXT_EXIT -eq 1 ]; then
    # No incomplete stories remain (all complete or skipped)
    echo "[ITER-$i] All stories complete or skipped" >&2

    # Check if truly all complete (not just skipped)
    INCOMPLETE_COUNT=$(jq '[.userStories[] | select(.passes == false)] | length' "$PRD_FILE")
    if [ "$INCOMPLETE_COUNT" -eq 0 ]; then
      echo ""
      echo "âœ“ TaskPlex completed all tasks!"
      echo "Completed at iteration $i of $MAX_ITERATIONS"

      # Merge to main if configured (US-006)
      merge_to_main

      exit 0
    else
      # Some skipped, partial completion
      SKIPPED_COUNT=$(jq '[.userStories[] | select(.status == "skipped")] | length' "$PRD_FILE")
      echo ""
      echo "âš ï¸  TaskPlex finished with $SKIPPED_COUNT skipped stories"
      echo "Check $PROGRESS_FILE for details"
      exit 1
    fi
  elif [ $GET_NEXT_EXIT -eq 2 ]; then
    # All remaining stories blocked by dependencies
    echo "[ITER-$i] All remaining stories are blocked by unmet dependencies" >&2
    break
  fi

  echo "[ITER-$i] Working on story: $CURRENT_STORY" >&2

  # Mark story as in progress
  update_story_status "$CURRENT_STORY" "in_progress"

  # Run fresh Claude agent with the taskplex prompt
  # Each iteration has clean context (no -c flag) to prevent context rot

  # Use temp file to capture output while tracking PID
  TEMP_OUTPUT="/tmp/taskplex-$$-$i.txt"
  echo "[ITER-$i] Starting Claude process, output to: $TEMP_OUTPUT" >&2
  echo "[ITER-$i] Timeout: ${ITERATION_TIMEOUT}s" >&2

  # Run with timeout
  $TIMEOUT_CMD $ITERATION_TIMEOUT claude -p "$(cat "$SCRIPT_DIR/prompt.md")" \
    --output-format json \
    --no-session-persistence \
    --agent implementer \
    --agents-dir "$PLUGIN_ROOT/agents" \
    --max-turns "$MAX_TURNS" \
    > "$TEMP_OUTPUT" 2>&1 &

  # Track PID for cleanup
  CURRENT_CLAUDE_PID=$!
  echo "[ITER-$i] Claude process started with PID: $CURRENT_CLAUDE_PID" >&2

  # Wait for completion
  EXIT_CODE=0
  ERROR_OCCURRED=0
  if wait $CURRENT_CLAUDE_PID; then
    echo "[ITER-$i] Claude process completed successfully" >&2
  else
    EXIT_CODE=$?
    ERROR_OCCURRED=1
    if [ $EXIT_CODE -eq 124 ]; then
      # Timeout (exit code 124 from timeout command)
      echo "[ITER-$i] Claude process timed out (exit code 124)" >&2
    else
      echo "[ITER-$i] Claude process exited with code $EXIT_CODE" >&2
    fi
  fi

  # Read output and cleanup temp file
  OUTPUT=$(cat "$TEMP_OUTPUT" 2>/dev/null || echo '{"error": "Failed to read output"}')
  rm -f "$TEMP_OUTPUT"
  CURRENT_CLAUDE_PID=""
  echo "[ITER-$i] Claude process cleanup complete" >&2

  # Handle errors (timeout, code errors, env issues, etc.)
  if [ $ERROR_OCCURRED -eq 1 ]; then
    handle_error $i "$CURRENT_STORY" "$EXIT_CODE" "$OUTPUT"
    RETRY=$?

    if [ $RETRY -eq 1 ]; then
      # User chose abort
      echo "Aborting TaskPlex execution"
      exit 1
    elif [ $RETRY -eq 2 ]; then
      # Retry with context (and extended timeout for timeout category)
      local category=$(categorize_error "$EXIT_CODE" "$OUTPUT")

      # Build retry context
      RETRY_CONTEXT="Previous attempt failed with error category: $category

Error excerpt:
$(echo "$OUTPUT" | head -c 500)

Please address the issue and try again."

      # For timeout category, use extended timeout (1.5x)
      if [ "$category" = "timeout" ]; then
        RETRY_TIMEOUT=$((ITERATION_TIMEOUT * 3 / 2))
        echo "Retrying iteration $i with extended timeout (${RETRY_TIMEOUT}s)..."
      else
        RETRY_TIMEOUT=$ITERATION_TIMEOUT
        echo "Retrying iteration $i with error context..."
      fi

      # Prepend retry context to prompt
      RETRY_PROMPT="$RETRY_CONTEXT

---

$(cat "$SCRIPT_DIR/prompt.md")"

      TEMP_OUTPUT="/tmp/taskplex-$$-$i-retry.txt"
      echo "$RETRY_PROMPT" | $TIMEOUT_CMD $RETRY_TIMEOUT claude -p - \
        --output-format json \
        --no-session-persistence \
        --agent implementer \
        --agents-dir "$PLUGIN_ROOT/agents" \
        --max-turns "$MAX_TURNS" \
        > "$TEMP_OUTPUT" 2>&1 &

      CURRENT_CLAUDE_PID=$!
      if wait $CURRENT_CLAUDE_PID; then
        OUTPUT=$(cat "$TEMP_OUTPUT" 2>/dev/null)
        rm -f "$TEMP_OUTPUT"
        CURRENT_CLAUDE_PID=""
        echo "[ITER-$i] Retry completed successfully" >&2
      else
        echo "âš ï¸  Retry also failed. Skipping story."
        rm -f "$TEMP_OUTPUT"
        CURRENT_CLAUDE_PID=""
        continue
      fi
    else
      # Skip this story (retry=0), continue to next iteration
      echo "Iteration $i complete (error, skipped). Continuing..."
      sleep 2
      continue
    fi
  fi

  # Extract result from JSON output
  RESULT=$(echo "$OUTPUT" | jq -r '.result // empty' 2>/dev/null || echo "$OUTPUT")

  # Display result
  echo "$RESULT"

  # Append to progress file
  echo "" >> "$PROGRESS_FILE"
  echo "=== Iteration $i $(date) ===" >> "$PROGRESS_FILE"
  echo "$RESULT" >> "$PROGRESS_FILE"

  # Run validator agent to verify acceptance criteria (US-007)
  VALIDATION_PASSED=0
  if [ "$CURRENT_STORY" != "unknown" ]; then
    if run_validator "$CURRENT_STORY"; then
      VALIDATION_PASSED=1
      echo "[VALIDATE-$CURRENT_STORY] âœ“ All acceptance criteria verified" >&2
    else
      VALIDATION_PASSED=0
      echo "[VALIDATE-$CURRENT_STORY] âœ— Validation failed" >&2

      # Treat validation failure like any other error
      VALIDATION_ERROR="Validator reported that acceptance criteria are not met. Review the implementation."

      # Handle validation error through standard error categorization
      handle_error $i "$CURRENT_STORY" 1 "$VALIDATION_ERROR"
      ERROR_HANDLING_RESULT=$?

      if [ $ERROR_HANDLING_RESULT -eq 0 ]; then
        # Skip this story
        echo "Skipping story $CURRENT_STORY after validation failure"
        continue
      elif [ $ERROR_HANDLING_RESULT -eq 1 ]; then
        # Abort
        echo "Aborting TaskPlex after validation failure"
        exit 1
      elif [ $ERROR_HANDLING_RESULT -eq 2 ]; then
        # Retry requested - loop will continue to next iteration
        echo "Retrying story $CURRENT_STORY after validation failure"
        continue
      fi
    fi
  fi

  # Only commit and mark complete if validation passed
  if [ "$VALIDATION_PASSED" -eq 1 ]; then
    # Commit changes after successful validation (US-006)
    # The agent stages files, script commits them
    if [ "$CURRENT_STORY" != "unknown" ]; then
      STORY_TITLE=$(jq -r --arg id "$CURRENT_STORY" '.userStories[] | select(.id == $id) | .title' "$PRD_FILE")
      if [ -n "$STORY_TITLE" ]; then
        commit_story "$CURRENT_STORY" "$STORY_TITLE"
      fi
    fi
  fi

  # Check for completion signal
  if echo "$RESULT" | grep -q "<promise>COMPLETE</promise>"; then
    # Mark current story as completed if validation passed
    if [ "$CURRENT_STORY" != "unknown" ] && [ "$VALIDATION_PASSED" -eq 1 ]; then
      update_story_status "$CURRENT_STORY" "completed"
    fi

    # Check if ALL stories are complete
    INCOMPLETE_COUNT=$(jq '[.userStories[] | select(.passes == false)] | length' "$PRD_FILE")
    if [ "$INCOMPLETE_COUNT" -eq 0 ]; then
      echo ""
      echo "âœ“ TaskPlex completed all tasks!"
      echo "Completed at iteration $i of $MAX_ITERATIONS"

      # Merge to main if configured (US-006)
      merge_to_main

      exit 0
    fi

    # Some stories still incomplete, continue
    echo "[ITER-$i] Story $CURRENT_STORY completed, but more stories remain" >&2
  fi

  # Check for errors
  if echo "$OUTPUT" | jq -e '.is_error' > /dev/null 2>&1; then
    ERROR_MSG=$(echo "$OUTPUT" | jq -r '.result // "Unknown error"')
    echo "âš  Warning: Iteration $i encountered an error: $ERROR_MSG"
    echo "Continuing to next iteration..."
  fi

  echo "Iteration $i complete. Continuing..."
  sleep 2
done

echo ""
echo "TaskPlex reached max iterations ($MAX_ITERATIONS) without completing all tasks."
echo "Check $PROGRESS_FILE for status."
exit 1
